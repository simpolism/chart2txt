<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>chart2txt - Convert Chart to Text</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
            line-height: 1.6;
        }
        h1, h2 {
            color: #2c3e50;
            text-align: center;
        }
        .container {
            background-color: #f9f9f9;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
        }
        input, select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        .time-inputs {
            display: flex;
            gap: 10px;
        }
        .time-inputs input, .time-inputs select {
            flex: 1;
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .checkbox-group input[type="checkbox"] {
            width: auto;
            margin: 0;
        }
        .checkbox-group label {
            margin: 0;
            font-weight: normal;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            display: block;
            width: 100%;
            margin-top: 20px;
        }
        button:hover {
            background-color: #2980b9;
        }
        .btn-secondary {
            background-color: #95a5a6;
            width: auto;
            display: inline-block;
            margin: 10px 5px 0 0;
            padding: 8px 12px;
            font-size: 14px;
        }
        .btn-secondary:hover {
            background-color: #7f8c8d;
        }
        .btn-danger {
            background-color: #e74c3c;
        }
        .btn-danger:hover {
            background-color: #c0392b;
        }
        .chart-container {
            background-color: #fff;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            position: relative;
        }
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        .chart-title {
            font-size: 18px;
            font-weight: 600;
            color: #2c3e50;
            margin: 0;
        }
        .remove-chart-btn {
            background-color: #e74c3c;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            width: auto;
            margin: 0;
        }
        .remove-chart-btn:hover {
            background-color: #c0392b;
        }
        #chartsContainer {
            margin-bottom: 20px;
        }
        #result {
            margin-top: 30px;
            white-space: pre-wrap;
            background-color: #fff;
            padding: 20px;
            border-radius: 4px;
            border-left: 4px solid #3498db;
        }
        .copy-btn {
            background-color: #2ecc71;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 15px;
            display: none;
        }
        .copy-btn:hover {
            background-color: #27ae60;
        }
        #loading {
            text-align: center;
            display: none;
            margin-top: 20px;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #3498db;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .error {
            color: #e74c3c;
            margin-top: 5px;
            font-size: 14px;
        }
        .aspect-strength-container {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            margin-top: 10px;
        }
        .aspect-strength-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            padding: 8px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #e9ecef;
            height: 40px;
            box-sizing: border-box;
        }
        .aspect-strength-row:last-child {
            margin-bottom: 0;
        }
        .aspect-label-input {
            width: 100px;
            padding: 4px 6px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-weight: 500;
            text-transform: uppercase;
            font-size: 11px;
            height: 20px;
            box-sizing: border-box;
        }
        .aspect-orb-input {
            width: 60px;
            padding: 4px 6px;
            border: 1px solid #ddd;
            border-radius: 3px;
            text-align: center;
            height: 20px;
            box-sizing: border-box;
        }
        .aspect-strength-controls {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        .btn-add {
            background-color: #28a745;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        .btn-add:hover {
            background-color: #218838;
        }
        .btn-reset {
            background-color: #6c757d;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        .btn-reset:hover {
            background-color: #5a6268;
        }
        .btn-remove {
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 0;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            margin-left: auto;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            line-height: 1;
            position: relative;
            top: -10px;
        }
        .btn-remove:hover {
            background-color: #c82333;
        }
        .aspect-orb-label {
            font-size: 11px;
            color: #666;
            margin-left: 2px;
        }
        footer {
            text-align: center;
            margin-top: 30px;
            padding: 15px;
            color: #7f8c8d;
            font-size: 14px;
            border-top: 1px solid #eee;
        }
        footer a {
            color: #3498db;
            text-decoration: none;
        }
        footer a:hover {
            text-decoration: underline;
        }
        .mode-toggle {
            display: flex;
            justify-content: center;
            gap: 0;
            margin-bottom: 20px;
        }
        .mode-toggle button {
            flex: 1;
            max-width: 200px;
            margin: 0;
            border-radius: 0;
            background-color: #bdc3c7;
            color: #2c3e50;
            border: 1px solid #95a5a6;
        }
        .mode-toggle button:first-child {
            border-radius: 4px 0 0 4px;
        }
        .mode-toggle button:last-child {
            border-radius: 0 4px 4px 0;
        }
        .mode-toggle button.active {
            background-color: #3498db;
            color: white;
            border-color: #3498db;
        }
        .mode-toggle button:hover:not(.active) {
            background-color: #a6acaf;
        }
        .astrology-only, .human-design-only {
            transition: opacity 0.2s ease;
        }
        .hidden-mode {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 id="pageTitle">Convert Astrological Chart to Text</h1>

        <div class="mode-toggle">
            <button type="button" id="modeAstrology" class="active">Astrology</button>
            <button type="button" id="modeHumanDesign">Human Design</button>
        </div>

        <form id="birthDataForm">
            <div id="chartsContainer">
                <!-- Charts will be dynamically added here -->
            </div>
            
            <button type="button" id="addChartBtn" class="btn-secondary astrology-only">Add Another Chart</button>

            <!-- Human Design Partnership Section -->
            <div id="hdPartnershipSection" class="human-design-only hidden-mode">
                <h2>Optional: Partnership Analysis</h2>
                <div class="checkbox-group">
                    <input type="checkbox" id="enableHdPartnership">
                    <label for="enableHdPartnership">Include Partner Chart</label>
                </div>
                <div id="hdPartnerChartContainer" style="display:none;">
                    <div class="chart-container">
                        <div class="chart-header">
                            <h3 class="chart-title">Partner Chart</h3>
                        </div>

                        <div class="form-group">
                            <label for="hdPartnerName">Name:</label>
                            <input type="text" id="hdPartnerName" placeholder="Partner's Name">
                        </div>

                        <div class="form-group">
                            <label for="hdPartnerBirthdate">Date:</label>
                            <input type="date" id="hdPartnerBirthdate">
                        </div>

                        <div class="form-group">
                            <label for="hdPartnerTime">Time (24 hour):</label>
                            <div class="time-inputs">
                                <input type="number" id="hdPartnerHours" min="0" max="23" placeholder="Hour">
                                <input type="number" id="hdPartnerMinutes" min="0" max="59" placeholder="Minute">
                            </div>
                        </div>

                        <div class="form-group">
                            <label for="hdPartnerLocation">Location:</label>
                            <input type="text" id="hdPartnerLocation" placeholder="City, Country">
                            <div id="hdPartnerLocationError" class="error"></div>
                        </div>
                    </div>
                </div>
            </div>

            <h2 class="astrology-only">Optional: Transits</h2>
            <div class="checkbox-group astrology-only">
                <input type="checkbox" id="enableTransits">
                <label for="enableTransits">Enable Transits</label>
            </div>
            <div id="transitLocationGroup" class="form-group astrology-only" style="display:none;">
                <label for="transitLocation">Transit Location:</label>
                <input type="text" id="transitLocation" placeholder="City, Country for Transits">
                <div id="transitLocationError" class="error"></div>
            </div>
            <div id="transitDateTimeGroup" class="form-group astrology-only" style="display:none;">
                <label for="transitDate">Transit Date:</label>
                <input type="date" id="transitDate">
                <label for="transitTime">Transit Time:</label>
                <div class="time-inputs">
                    <input type="number" id="transitHours" min="0" max="23" placeholder="Hour">
                    <input type="number" id="transitMinutes" min="0" max="59" placeholder="Minute">
                </div>
            </div>

            <div class="form-group astrology-only">
                <label for="houseSystem">House System (for all charts):</label>
                <select id="houseSystem">
                    <option value="P" selected>Placidus</option>
                    <option value="W">Whole Sign</option>
                    <option value="E">Equal</option>
                    <option value="O">Porphyry</option>
                </select>
            </div>

            <div class="form-group astrology-only">
                <label>Aspect Grouping Categories:</label>
                <div class="aspect-strength-container">
                    <div id="aspectThresholdsList">
                        <!-- Dynamic threshold rows will be added here -->
                    </div>
                    <div class="aspect-strength-controls">
                        <button type="button" id="addThreshold" class="btn-add">+ Add Category</button>
                        <button type="button" id="resetThresholds" class="btn-reset">Reset to Defaults</button>
                    </div>
                </div>
            </div>
            
            <button type="submit">Generate Chart Description</button>
        </form>
        
        <div id="loading">
            <div class="spinner"></div>
            <p>Calculating chart(s)...</p>
        </div>
        
        <button id="copyBtn" class="copy-btn">Copy to Clipboard</button>
        <div id="result"></div>
        
        <footer>
            Built with <a href="https://github.com/simpolism/chart2txt" target="_blank">chart2txt</a>, 
            <a href="https://github.com/simpolism/simple-astro-api" target="_blank">simple-astro-api</a>, 
            and <a href="https://photon.komoot.io" target="_blank">Photon Geocoding API</a>.
        </footer>
    </div>

    <!-- <script src="https://cdn.jsdelivr.net/npm/chart2txt@0.7.1/dist/chart2txt.min.js"></script> -->
    <script src="../../dist/chart2txt.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const MAX_CHARTS = 10;
            let chartCounter = 0;
            let charts = [];

            const form = document.getElementById('birthDataForm');
            const chartsContainer = document.getElementById('chartsContainer');
            const addChartBtn = document.getElementById('addChartBtn');
            const resultDiv = document.getElementById('result');
            const loadingDiv = document.getElementById('loading');
            const copyBtn = document.getElementById('copyBtn');

            // Transit inputs
            const enableTransitsCheckbox = document.getElementById('enableTransits');
            const transitLocationGroup = document.getElementById('transitLocationGroup');
            const transitLocationInput = document.getElementById('transitLocation');
            const transitLocationError = document.getElementById('transitLocationError');
            const transitDateTimeGroup = document.getElementById('transitDateTimeGroup');
            const transitDateInput = document.getElementById('transitDate');
            const transitHoursInput = document.getElementById('transitHours');
            const transitMinutesInput = document.getElementById('transitMinutes');
            const houseSystemSelect = document.getElementById('houseSystem');

            // Aspect strength threshold elements
            const aspectThresholdsList = document.getElementById('aspectThresholdsList');
            const addThresholdBtn = document.getElementById('addThreshold');
            const resetThresholdsBtn = document.getElementById('resetThresholds');
            let thresholdCounter = 0;

            // Mode toggle elements
            const modeAstrologyBtn = document.getElementById('modeAstrology');
            const modeHumanDesignBtn = document.getElementById('modeHumanDesign');
            const pageTitle = document.getElementById('pageTitle');
            let currentMode = 'astrology'; // 'astrology' or 'humandesign'

            // HD Partnership elements
            const hdPartnershipSection = document.getElementById('hdPartnershipSection');
            const enableHdPartnershipCheckbox = document.getElementById('enableHdPartnership');
            const hdPartnerChartContainer = document.getElementById('hdPartnerChartContainer');
            const hdPartnerNameInput = document.getElementById('hdPartnerName');
            const hdPartnerBirthdateInput = document.getElementById('hdPartnerBirthdate');
            const hdPartnerHoursInput = document.getElementById('hdPartnerHours');
            const hdPartnerMinutesInput = document.getElementById('hdPartnerMinutes');
            const hdPartnerLocationInput = document.getElementById('hdPartnerLocation');
            const hdPartnerLocationError = document.getElementById('hdPartnerLocationError');

            // HD Partnership checkbox event listener
            enableHdPartnershipCheckbox.addEventListener('change', function() {
                hdPartnerChartContainer.style.display = this.checked ? 'block' : 'none';
                saveFormData();
            });

            // API endpoints
            const ASTROLOGY_API_ENDPOINT = 'https://simple-astro-api.netlify.app/api/positions';
            const HUMAN_DESIGN_API_ENDPOINT = 'https://simple-astro-api.netlify.app/api/positions-with-design';

            // Mode toggle functions
            function setMode(mode) {
                currentMode = mode;
                const astrologyElements = document.querySelectorAll('.astrology-only');
                const humanDesignElements = document.querySelectorAll('.human-design-only');

                if (mode === 'astrology') {
                    modeAstrologyBtn.classList.add('active');
                    modeHumanDesignBtn.classList.remove('active');
                    pageTitle.textContent = 'Convert Astrological Chart to Text';
                    astrologyElements.forEach(el => el.classList.remove('hidden-mode'));
                    humanDesignElements.forEach(el => el.classList.add('hidden-mode'));
                    // Show all charts in astrology mode
                    document.querySelectorAll('#chartsContainer .chart-container').forEach((el, index) => {
                        el.style.display = 'block';
                    });
                    // Show "Is Event?" checkbox in astrology mode
                    document.querySelectorAll('.checkbox-group').forEach(el => {
                        const checkbox = el.querySelector('input[type="checkbox"]');
                        if (checkbox && checkbox.id.startsWith('isEvent_')) {
                            el.style.display = 'flex';
                        }
                    });
                    updateAddButtonVisibility();
                } else {
                    modeAstrologyBtn.classList.remove('active');
                    modeHumanDesignBtn.classList.add('active');
                    pageTitle.textContent = 'Convert Human Design Chart to Text';
                    astrologyElements.forEach(el => el.classList.add('hidden-mode'));
                    humanDesignElements.forEach(el => el.classList.remove('hidden-mode'));
                    // Only show first chart in HD mode (single chart only)
                    document.querySelectorAll('#chartsContainer .chart-container').forEach((el, index) => {
                        el.style.display = index === 0 ? 'block' : 'none';
                    });
                    // Hide "Is Event?" checkbox in HD mode
                    document.querySelectorAll('.checkbox-group').forEach(el => {
                        const checkbox = el.querySelector('input[type="checkbox"]');
                        if (checkbox && checkbox.id.startsWith('isEvent_')) {
                            el.style.display = 'none';
                        }
                    });
                    // Update partnership container visibility based on checkbox
                    hdPartnerChartContainer.style.display = enableHdPartnershipCheckbox.checked ? 'block' : 'none';
                }

                // Save mode preference
                localStorage.setItem('chartMode', mode);
            }

            // Mode toggle event listeners
            modeAstrologyBtn.addEventListener('click', () => setMode('astrology'));
            modeHumanDesignBtn.addEventListener('click', () => setMode('humandesign'));

            // Chart template for creating new charts
            function createChartHTML(chartId, chartNumber) {
                return `
                    <div class="chart-container" data-chart-id="${chartId}">
                        <div class="chart-header">
                            <h3 class="chart-title">Chart ${chartNumber}</h3>
                            ${chartNumber > 1 ? `<button type="button" class="remove-chart-btn" onclick="removeChart('${chartId}')">Remove Chart</button>` : ''}
                        </div>
                        
                        <div class="form-group">
                            <label for="name_${chartId}">Name:</label>
                            <input type="text" id="name_${chartId}" placeholder="Name">
                        </div>
                        
                        <div class="checkbox-group">
                            <input type="checkbox" id="isEvent_${chartId}">
                            <label for="isEvent_${chartId}">Is Event?</label>
                        </div>
                        
                        <div class="form-group">
                            <label for="birthdate_${chartId}">Date:</label>
                            <input type="date" id="birthdate_${chartId}" required>
                        </div>
                        
                        <div class="form-group">
                            <label for="birthtime_${chartId}">Time (24 hour):</label>
                            <div class="time-inputs">
                                <input type="number" id="hours_${chartId}" min="0" max="23" placeholder="Hour" required>
                                <input type="number" id="minutes_${chartId}" min="0" max="59" placeholder="Minute" required>
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label for="location_${chartId}">Location:</label>
                            <input type="text" id="location_${chartId}" placeholder="City, Country" required>
                            <div id="locationError_${chartId}" class="error"></div>
                        </div>
                    </div>
                `;
            }
            // Initialize with first chart
            function initializeCharts() {
                // Load chart structure first
                const savedChartStructure = localStorage.getItem('chartStructure');
                const savedChartCounter = localStorage.getItem('chartCounter');
                
                if (savedChartStructure && savedChartCounter) {
                    const savedCharts = JSON.parse(savedChartStructure);
                    chartCounter = parseInt(savedChartCounter);
                    
                    // Recreate charts with their original IDs
                    savedCharts.forEach(savedChart => {
                        recreateChart(savedChart.id, savedChart.number);
                    });
                } else {
                    // Create first chart if no saved structure
                    addChart(true); // skipSave = true
                }
                
                // Load form data after all charts are created
                loadFormData();
            }

            // Recreate a chart with specific ID (for localStorage loading)
            function recreateChart(chartId, chartNumber) {
                charts.push({
                    id: chartId,
                    number: chartNumber
                });

                const chartHTML = createChartHTML(chartId, chartNumber);
                chartsContainer.insertAdjacentHTML('beforeend', chartHTML);
                
                updateAddButtonVisibility();
                attachChartEventListeners(chartId);
            }

            // Add a new chart
            function addChart(skipSave = false) {
                if (charts.length >= MAX_CHARTS) {
                    alert(`Maximum of ${MAX_CHARTS} charts allowed.`);
                    return;
                }

                chartCounter++;
                const chartId = `chart_${chartCounter}`;
                const chartNumber = charts.length + 1;
                
                charts.push({
                    id: chartId,
                    number: chartNumber
                });

                const chartHTML = createChartHTML(chartId, chartNumber);
                chartsContainer.insertAdjacentHTML('beforeend', chartHTML);
                
                updateAddButtonVisibility();
                attachChartEventListeners(chartId);
                
                if (!skipSave) {
                    saveFormData();
                }
            }

            // Remove a chart
            window.removeChart = function(chartId) {
                const chartElement = document.querySelector(`[data-chart-id="${chartId}"]`);
                if (chartElement) {
                    chartElement.remove();
                    charts = charts.filter(chart => chart.id !== chartId);
                    renumberCharts();
                    updateAddButtonVisibility();
                    saveFormData();
                }
            };

            // Renumber charts after removal
            function renumberCharts() {
                charts.forEach((chart, index) => {
                    chart.number = index + 1;
                    const chartElement = document.querySelector(`[data-chart-id="${chart.id}"]`);
                    if (chartElement) {
                        const titleElement = chartElement.querySelector('.chart-title');
                        titleElement.textContent = `Chart ${chart.number}`;
                    }
                });
            }

            // Update visibility of add chart button
            function updateAddButtonVisibility() {
                addChartBtn.style.display = charts.length >= MAX_CHARTS ? 'none' : 'inline-block';
            }

            // Attach event listeners to chart inputs
            function attachChartEventListeners(chartId) {
                const chartInputs = [
                    `name_${chartId}`, `isEvent_${chartId}`, `birthdate_${chartId}`,
                    `hours_${chartId}`, `minutes_${chartId}`, `location_${chartId}`
                ];
                
                chartInputs.forEach(inputId => {
                    const element = document.getElementById(inputId);
                    if (element) {
                        const eventType = (element.type === 'checkbox' || element.type === 'date') ? 'change' : 'input';
                        element.addEventListener(eventType, saveFormData);
                    }
                });
            }

            // Get all chart field IDs for persistence
            function getAllChartFieldIds() {
                const fieldIds = [];
                charts.forEach(chart => {
                    fieldIds.push(
                        `name_${chart.id}`, `isEvent_${chart.id}`, `birthdate_${chart.id}`,
                        `hours_${chart.id}`, `minutes_${chart.id}`, `location_${chart.id}`
                    );
                });
                return fieldIds;
            }

            // Save form data to localStorage
            function saveFormData() {
                // Save chart structure
                localStorage.setItem('chartStructure', JSON.stringify(charts));
                localStorage.setItem('chartCounter', chartCounter.toString());
                
                // Save chart field values
                const chartFieldIds = getAllChartFieldIds();
                chartFieldIds.forEach(fieldId => {
                    const field = document.getElementById(fieldId);
                    if (field) {
                        if (field.type === 'checkbox') {
                            localStorage.setItem(`chartForm_${fieldId}`, field.checked);
                        } else {
                            localStorage.setItem(`chartForm_${fieldId}`, field.value);
                        }
                    }
                });

                // Save transit and other fields
                const otherFields = [
                    'enableTransits', 'transitLocation', 'transitDate', 
                    'transitHours', 'transitMinutes', 'houseSystem'
                ];
                otherFields.forEach(fieldId => {
                    const field = document.getElementById(fieldId);
                    if (field) {
                        if (field.type === 'checkbox') {
                            localStorage.setItem(`chartForm_${fieldId}`, field.checked);
                        } else {
                            localStorage.setItem(`chartForm_${fieldId}`, field.value);
                        }
                    }
                });

                // Save aspect strength thresholds
                const aspectThresholds = getUiCategories();
                localStorage.setItem('chartForm_aspectThresholds', JSON.stringify(aspectThresholds));
            }

            // Load form data from localStorage
            function loadFormData() {
                // Load chart field values
                const chartFieldIds = getAllChartFieldIds();
                chartFieldIds.forEach(fieldId => {
                    const field = document.getElementById(fieldId);
                    if (field) {
                        const savedValue = localStorage.getItem(`chartForm_${fieldId}`);
                        if (savedValue !== null) {
                            if (field.type === 'checkbox') {
                                field.checked = (savedValue === 'true');
                            } else {
                                field.value = savedValue;
                            }
                        }
                    }
                });

                // Load transit and other fields
                const otherFields = [
                    'enableTransits', 'transitLocation', 'transitDate', 
                    'transitHours', 'transitMinutes', 'houseSystem'
                ];
                otherFields.forEach(fieldId => {
                    const field = document.getElementById(fieldId);
                    if (field) {
                        const savedValue = localStorage.getItem(`chartForm_${fieldId}`);
                        if (savedValue !== null) {
                            if (field.type === 'checkbox') {
                                field.checked = (savedValue === 'true');
                            } else {
                                field.value = savedValue;
                            }
                        }
                    }
                });

                // Update transit field visibility
                updateTransitFieldsVisibility();
                
                // Initialize aspect strength thresholds
                initializeAspectStrengthThresholds();
            }

            // Update transit fields visibility
            function updateTransitFieldsVisibility() {
                const showTransitFields = enableTransitsCheckbox.checked;
                transitLocationGroup.style.display = showTransitFields ? 'block' : 'none';
                transitDateTimeGroup.style.display = showTransitFields ? 'block' : 'none';
                
                if (showTransitFields && !transitDateInput.value) {
                    const now = new Date();
                    transitDateInput.value = `${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}`;
                    transitHoursInput.value = now.getHours().toString().padStart(2, '0');
                    transitMinutesInput.value = now.getMinutes().toString().padStart(2, '0');
                }
            }

            // Create a threshold row
            function createThresholdRow(label = '', orb = '') {
                thresholdCounter++;
                const thresholdId = `threshold_${thresholdCounter}`;
                
                // Format orb value to always have one decimal place
                const formattedOrb = orb ? parseFloat(orb).toFixed(1) : '';
                
                const row = document.createElement('div');
                row.className = 'aspect-strength-row';
                row.dataset.thresholdId = thresholdId;
                
                row.innerHTML = `
                    <input type="text" class="aspect-label-input" placeholder="LABEL" value="${label}" data-field="label">
                    <input type="number" class="aspect-orb-input" placeholder="0.0" value="${formattedOrb}" min="0" max="30" step="0.1" data-field="orb">
                    <span class="aspect-orb-label">max orb</span>
                    <button type="button" class="btn-remove" onclick="removeThreshold('${thresholdId}')">×</button>
                `;
                
                // Add event listeners for the inputs
                const inputs = row.querySelectorAll('input');
                inputs.forEach(input => {
                    input.addEventListener('input', saveFormData);
                });

                // Format number input to always show one decimal place
                const orbInput = row.querySelector('[data-field="orb"]');
                if (orbInput) {
                    orbInput.addEventListener('blur', function() {
                        const value = parseFloat(this.value);
                        if (!isNaN(value)) {
                            this.value = value.toFixed(1);
                        }
                    });
                }
                
                aspectThresholdsList.appendChild(row);
                return thresholdId;
            }

            // Remove a threshold row
            window.removeThreshold = function(thresholdId) {
                const row = document.querySelector(`[data-threshold-id="${thresholdId}"]`);
                if (row) {
                    row.remove();
                    saveFormData();
                }
            };

            // Add a new threshold
            function addThreshold() {
                createThresholdRow();
                saveFormData();
            }

            // Reset aspect strength thresholds to defaults
            function resetAspectStrengthThresholds() {
                aspectThresholdsList.innerHTML = '';
                thresholdCounter = 0;
                createThresholdRow('TIGHT', '2.0');
                createThresholdRow('MODERATE', '4.0');
                createThresholdRow('WIDE', '7.0');
                saveFormData();
            }

            /**
             * Reads the user-defined aspect categories and their orb thresholds from the UI.
             * @returns {Array<Object>} An array of category objects, sorted by orb.
             *   Example: [{ label: 'TIGHT', orb: 2.0 }, { label: 'MODERATE', orb: 4.0 }]
             */
            function getUiCategories() {
                const categories = [];
                const rows = aspectThresholdsList.querySelectorAll('.aspect-strength-row');
                
                rows.forEach(row => {
                    const labelInput = row.querySelector('[data-field="label"]');
                    const orbInput = row.querySelector('[data-field="orb"]');
                    
                    const label = labelInput.value.trim().toUpperCase();
                    const orb = parseFloat(orbInput.value);
                    
                    if (label && !isNaN(orb)) {
                        categories.push({ label: label, orb: orb });
                    }
                });
                
                // Sort categories by orb to ensure correct grouping.
                categories.sort((a, b) => a.orb - b.orb);
                
                return categories;
            }

            /**
             * Groups aspects based on the simple orb categories defined in the UI.
             * This function demonstrates the "custom grouping" step of the advanced workflow.
             *
             * @param {Array<Object>} aspects - The raw aspect data from analyzeCharts().
             * @param {Array<Object>} uiCategories - The categories defined by the user.
             * @returns {Map<string, Array<Object>>} - A map of grouped aspects for the report.
             */
            function groupAspectsFromUiSettings(aspects, uiCategories) {
                const grouped = new Map();
                let lastOrb = 0;

                // Initialize the map to maintain the user-defined order.
                uiCategories.forEach(cat => {
                    const orbRangeStr = `orb ${lastOrb.toFixed(1)}-${cat.orb.toFixed(1)}°`;
                    const mapKey = `[${cat.label} ASPECTS: ${orbRangeStr}]`;
                    grouped.set(mapKey, []);
                    lastOrb = cat.orb;
                });

                aspects.forEach(aspect => {
                    // ADVANCED USER HOOK:
                    // This is where you could implement more complex logic.
                    // For example, you could create a "significance score" and group by that,
                    // instead of just grouping by orb.
                    //
                    // Example of adding more logic:
                    // let isImportant = false;
                    // if (['Sun', 'Moon'].includes(aspect.planetA) || ['Sun', 'Moon'].includes(aspect.planetB)) {
                    //     isImportant = true;
                    // }
                    // if (isImportant) {
                    //     // Add to a special "LUMINARY ASPECTS" group.
                    // }

                    // Find the correct category for this aspect based on its orb.
                    let assignedCategory = null;
                    for (const category of uiCategories) {
                        if (aspect.orb <= category.orb) {
                            assignedCategory = category;
                            break; // Found the tightest category it fits into.
                        }
                    }

                    if (assignedCategory) {
                        // Re-find the key to add the aspect to the list.
                        let lastOrb = 0;
                        for (const cat of uiCategories) {
                            if (cat.label === assignedCategory.label) {
                                const orbRangeStr = `orb ${lastOrb.toFixed(1)}-${cat.orb.toFixed(1)}°`;
                                const mapKey = `[${cat.label} ASPECTS: ${orbRangeStr}]`;
                                grouped.get(mapKey).push(aspect);
                                break;
                            }
                            lastOrb = cat.orb;
                        }
                    }
                });

                // Clean up empty categories and sort the aspects within each group by orb.
                for (const [key, aspectList] of grouped.entries()) {
                    if (aspectList.length === 0) {
                        grouped.delete(key);
                    } else {
                        aspectList.sort((a, b) => a.orb - b.orb);
                    }
                }

                return grouped;
            }

            // Initialize aspect strength thresholds
            function initializeAspectStrengthThresholds() {
                const savedThresholds = localStorage.getItem('chartForm_aspectThresholds');
                
                if (savedThresholds) {
                    try {
                        const thresholds = JSON.parse(savedThresholds);
                        aspectThresholdsList.innerHTML = '';
                        thresholdCounter = 0;
                        
                        thresholds.forEach(cat => {
                            createThresholdRow(cat.label, cat.orb.toString());
                        });
                    } catch (error) {
                        console.error('Error loading saved thresholds:', error);
                        resetAspectStrengthThresholds();
                    }
                } else {
                    resetAspectStrengthThresholds();
                }
            }

            // Event listeners
            addChartBtn.addEventListener('click', addChart);
            
            enableTransitsCheckbox.addEventListener('change', function() {
                updateTransitFieldsVisibility();
                saveFormData();
            });

            addThresholdBtn.addEventListener('click', addThreshold);
            resetThresholdsBtn.addEventListener('click', resetAspectStrengthThresholds);

            // Other field event listeners
            ['transitLocation', 'transitDate', 'transitHours', 'transitMinutes', 'houseSystem'].forEach(fieldId => {
                const field = document.getElementById(fieldId);
                if (field) {
                    const eventType = (field.type === 'date') ? 'change' : 'input';
                    field.addEventListener(eventType, saveFormData);
                }
            });
            
            copyBtn.addEventListener('click', function() {
                const textToCopy = resultDiv.textContent;
                if (textToCopy) {
                    navigator.clipboard.writeText(textToCopy)
                        .then(() => {
                            const originalText = copyBtn.textContent;
                            copyBtn.textContent = 'Copied!';
                            setTimeout(() => {
                                copyBtn.textContent = originalText;
                            }, 2000);
                        })
                        .catch(err => {
                            console.error('Failed to copy text: ', err);
                        });
                }
            });
            
            // API_ENDPOINT is now defined at the top as ASTROLOGY_API_ENDPOINT
            
            // Form submission handler
            form.addEventListener('submit', async function(e) {
                e.preventDefault();

                resultDiv.textContent = '';
                copyBtn.style.display = 'none';
                loadingDiv.style.display = 'block';

                // Clear all error messages
                charts.forEach(chart => {
                    const errorElement = document.getElementById(`locationError_${chart.id}`);
                    if (errorElement) errorElement.textContent = '';
                });
                transitLocationError.textContent = '';

                try {
                    // Branch based on current mode
                    if (currentMode === 'humandesign') {
                        await processHumanDesignChart();
                    } else {
                        await processAstrologyCharts();
                    }
                } catch (error) {
                    console.error('Error generating chart:', error);
                    resultDiv.textContent = 'Error: ' + error.message;
                } finally {
                    loadingDiv.style.display = 'none';
                }
            });

            // Human Design chart processing
            async function processHumanDesignChart() {
                const chart = charts[0]; // HD only uses first chart
                if (!chart) {
                    resultDiv.textContent = 'Please provide chart data.';
                    return;
                }

                const nameInput = document.getElementById(`name_${chart.id}`);
                const birthdateInput = document.getElementById(`birthdate_${chart.id}`);
                const hoursInput = document.getElementById(`hours_${chart.id}`);
                const minutesInput = document.getElementById(`minutes_${chart.id}`);
                const locationInput = document.getElementById(`location_${chart.id}`);
                const locationError = document.getElementById(`locationError_${chart.id}`);

                const name = nameInput.value.trim() || 'Person 1';
                const birthdate = birthdateInput.value;
                const hours = parseInt(hoursInput.value);
                const minutes = parseInt(minutesInput.value);
                const location = locationInput.value.trim();

                if (!birthdate || isNaN(hours) || isNaN(minutes) || !location) {
                    locationError.textContent = 'Please fill all required date, time, and location fields.';
                    return;
                }

                const coordinates = await geocodeLocation(location, locationError);
                if (!coordinates) return;

                const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:00`;

                // Call Human Design API for first person
                const url = `${HUMAN_DESIGN_API_ENDPOINT}?date=${birthdate}&time=${timeString}&lat=${coordinates.latitude}&lng=${coordinates.longitude}`;
                const response = await fetch(url);

                if (!response.ok) {
                    locationError.textContent = `API error: ${response.statusText || response.status}`;
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const apiResponse1 = await response.json();

                // Check if partnership mode is enabled
                if (enableHdPartnershipCheckbox.checked) {
                    // Get partner data
                    const partnerName = hdPartnerNameInput.value.trim() || 'Person 2';
                    const partnerBirthdate = hdPartnerBirthdateInput.value;
                    const partnerHours = parseInt(hdPartnerHoursInput.value);
                    const partnerMinutes = parseInt(hdPartnerMinutesInput.value);
                    const partnerLocation = hdPartnerLocationInput.value.trim();

                    if (!partnerBirthdate || isNaN(partnerHours) || isNaN(partnerMinutes) || !partnerLocation) {
                        hdPartnerLocationError.textContent = 'Please fill all required partner date, time, and location fields.';
                        return;
                    }

                    const partnerCoordinates = await geocodeLocation(partnerLocation, hdPartnerLocationError);
                    if (!partnerCoordinates) return;

                    const partnerTimeString = `${partnerHours.toString().padStart(2, '0')}:${partnerMinutes.toString().padStart(2, '0')}:00`;

                    // Call Human Design API for partner
                    const partnerUrl = `${HUMAN_DESIGN_API_ENDPOINT}?date=${partnerBirthdate}&time=${partnerTimeString}&lat=${partnerCoordinates.latitude}&lng=${partnerCoordinates.longitude}`;
                    const partnerResponse = await fetch(partnerUrl);

                    if (!partnerResponse.ok) {
                        hdPartnerLocationError.textContent = `API error: ${partnerResponse.statusText || partnerResponse.status}`;
                        throw new Error(`HTTP error! status: ${partnerResponse.status}`);
                    }

                    const apiResponse2 = await partnerResponse.json();

                    // Generate Partnership analysis using the library
                    const textDescription = window.chart2txt.humandesignPartnership2txt(apiResponse1, apiResponse2, {
                        person1Name: name,
                        person1Location: location,
                        person2Name: partnerName,
                        person2Location: partnerLocation
                    });

                    resultDiv.textContent = textDescription;
                    copyBtn.style.display = 'block';
                } else {
                    // Single chart mode
                    const textDescription = window.chart2txt.humandesign2txt(apiResponse1, {
                        name: name,
                        location: location
                    });

                    resultDiv.textContent = textDescription;
                    copyBtn.style.display = 'block';
                }
            }

            // Astrology chart processing
            async function processAstrologyCharts() {
                const multiChartData = [];
                const houseSystem = houseSystemSelect.value;

                // Process each chart
                for (const chart of charts) {
                    const chartData = await processChart(chart, houseSystem);
                    if (chartData) {
                        multiChartData.push(chartData);
                    } else {
                        return; // Error occurred, stop processing
                    }
                }

                // Process transit data if enabled
                if (enableTransitsCheckbox.checked) {
                    const transitData = await processTransitData(houseSystem);
                    if (transitData) {
                        multiChartData.push(transitData);
                    } else {
                        return; // Error occurred, stop processing
                    }
                }

                if (multiChartData.length === 0) {
                    resultDiv.textContent = 'Please provide at least one chart.';
                    return;
                }

                // --- ADVANCED WORKFLOW DEMONSTRATION ---

                // 1. ANALYZE: Get the raw, ungrouped report from the library.
                const analysisSettings = {
                    includeAspectPatterns: true,
                    includeSignDistributions: true
                };
                const report = window.chart2txt.analyzeCharts(multiChartData, analysisSettings);

                // --- CUSTOM FILTERING & GROUPING DEMONSTRATION ---

                // 2a. GET UI DEFINITIONS & DETERMINE MAX ORB
                const uiCategories = getUiCategories(); // Get categories from the UI.

                // Find the widest orb defined by the user to use as a filter threshold.
                // If no categories are defined, default to a wide orb so nothing is filtered.
                const maxOrbThreshold = uiCategories.length > 0 ? uiCategories[uiCategories.length - 1].orb : 10.0;

                // 2b. FILTER THE RAW REPORT
                // This is a powerful step. We remove any aspects that are wider than the user's
                // widest defined category, cleaning the data before grouping.
                console.log('Report before filtering:', JSON.parse(JSON.stringify(report)));

                // Filter single-chart analyses
                const singleChartMaxPatternOrb = 2.5;
                report.chartAnalyses.forEach(ca => {
                    ca.aspects = ca.aspects.filter(aspect => aspect.orb <= maxOrbThreshold);
                    ca.patterns = ca.patterns.filter(pattern => {
                        if (pattern.type === 'Yod') return pattern.averageOrb <= 1.0;
                        return pattern.averageOrb < singleChartMaxPatternOrb;
                    });
                });

                // Filter multi-chart analyses (pairwise, transit, global)
                const multiChartMaxPatternOrb = 1.5;
                report.pairwiseAnalyses.forEach(pa => {
                    pa.synastryAspects = pa.synastryAspects.filter(aspect => aspect.orb <= maxOrbThreshold);
                    pa.compositePatterns = pa.compositePatterns.filter(pattern => {
                        if (pattern.type === 'Yod') return pattern.averageOrb <= 0.5;
                        return pattern.averageOrb <= multiChartMaxPatternOrb;
                    });
                });
                report.transitAnalyses.forEach(ta => {
                    ta.aspects = ta.aspects.filter(aspect => aspect.orb <= maxOrbThreshold);
                    ta.patterns = ta.patterns.filter(pattern => {
                        if (pattern.type === 'Yod') return pattern.averageOrb <= 0.5;
                        return pattern.averageOrb <= multiChartMaxPatternOrb;
                    });
                });
                if (report.globalAnalysis) {
                    report.globalAnalysis.patterns = report.globalAnalysis.patterns.filter(pattern => {
                        if (pattern.type === 'Yod') return pattern.averageOrb <= 0.5;
                        return pattern.averageOrb <= multiChartMaxPatternOrb;
                    });
                }
                if (report.globalTransitAnalysis) {
                    report.globalTransitAnalysis.patterns = report.globalTransitAnalysis.patterns.filter(pattern => {
                        if (pattern.type === 'Yod') return pattern.averageOrb <= 0.5;
                        return pattern.averageOrb <= multiChartMaxPatternOrb;
                    });
                }

                console.log('Report after filtering:', JSON.parse(JSON.stringify(report)));

                // 2c. GROUP THE FILTERED ASPECTS
                // Now, we pass the cleaned-up data to our grouping function.
                report.chartAnalyses.forEach(ca => {
                    ca.groupedAspects = groupAspectsFromUiSettings(ca.aspects, uiCategories);
                });
                report.pairwiseAnalyses.forEach(pa => {
                    // For multi-chart aspects, we can use a different grouping or the same one.
                    // Here, we'll just use the same UI categories for simplicity.
                    pa.groupedSynastryAspects = groupAspectsFromUiSettings(pa.synastryAspects, uiCategories);
                });
                report.transitAnalyses.forEach(ta => {
                    ta.groupedAspects = groupAspectsFromUiSettings(ta.aspects, uiCategories);
                });

                // 3. FORMAT: Pass the modified report object to the formatter.
                const textDescription = window.chart2txt.formatReportToText(report);

                resultDiv.textContent = textDescription;
                copyBtn.style.display = 'block';
            }

            // Process individual chart data
            async function processChart(chart, houseSystem) {
                const nameInput = document.getElementById(`name_${chart.id}`);
                const isEventInput = document.getElementById(`isEvent_${chart.id}`);
                const birthdateInput = document.getElementById(`birthdate_${chart.id}`);
                const hoursInput = document.getElementById(`hours_${chart.id}`);
                const minutesInput = document.getElementById(`minutes_${chart.id}`);
                const locationInput = document.getElementById(`location_${chart.id}`);
                const locationError = document.getElementById(`locationError_${chart.id}`);

                const name = nameInput.value.trim();
                const isEvent = isEventInput.checked;
                const birthdate = birthdateInput.value;
                const hours = parseInt(hoursInput.value);
                const minutes = parseInt(minutesInput.value);
                const location = locationInput.value.trim();

                if (!birthdate || isNaN(hours) || isNaN(minutes) || !location) {
                    locationError.textContent = `Chart ${chart.number}: Please fill all required date, time, and location fields.`;
                    return null;
                }

                const coordinates = await geocodeLocation(location, locationError);
                if (!coordinates) {
                    return null;
                }

                const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:00`;
                const apiData = await getPlanetaryPositions(birthdate, timeString, coordinates.latitude, coordinates.longitude, houseSystem, locationError);
                if (!apiData) {
                    return null;
                }

                return {
                    name: name || `Chart ${chart.number}`,
                    planets: apiData.planets.map(({ name, longitude, speed }) => ({ name, degree: longitude, speed })),
                    ascendant: apiData.ascendant,
                    midheaven: apiData.midheaven,
                    points: apiData.points || [],
                    houseCusps: apiData.houseCusps,
                    location: location,
                    timestamp: new Date(`${apiData.date.replace(/-/g, '/')} ${apiData.time.replace(/-/g, ':')}`),
                    chartType: isEvent ? 'event' : 'natal',
                };
            }

            // Process transit data
            async function processTransitData(houseSystem) {
                const transitLocation = transitLocationInput.value.trim();
                if (!transitLocation) {
                    transitLocationError.textContent = 'Please enter a location for transits.';
                    return null;
                }

                const coordinatesTransit = await geocodeLocation(transitLocation, transitLocationError);
                if (!coordinatesTransit) {
                    return null;
                }
                
                let transitDate = transitDateInput.value;
                let transitHours = parseInt(transitHoursInput.value);
                let transitMinutes = parseInt(transitMinutesInput.value);
                let transitTimestamp = new Date();

                if (transitDate && !isNaN(transitHours) && !isNaN(transitMinutes)) {
                    transitTimestamp = new Date(`${transitDate}T${transitHours.toString().padStart(2, '0')}:${transitMinutes.toString().padStart(2, '0')}:00`);
                } else {
                    transitDate = `${transitTimestamp.getFullYear()}-${(transitTimestamp.getMonth() + 1).toString().padStart(2, '0')}-${transitTimestamp.getDate().toString().padStart(2, '0')}`;
                    transitHours = transitTimestamp.getHours();
                    transitMinutes = transitTimestamp.getMinutes();
                }
                
                const transitTimeString = `${transitHours.toString().padStart(2, '0')}:${transitMinutes.toString().padStart(2, '0')}:00`;
                
                const apiDataTransit = await getPlanetaryPositions(transitDate, transitTimeString, coordinatesTransit.latitude, coordinatesTransit.longitude, houseSystem, transitLocationError);
                if (!apiDataTransit) {
                    return null;
                }

                return {
                    name: `Transits for ${transitDate} at ${transitLocation}`,
                    planets: apiDataTransit.planets.map(({ name, longitude, speed }) => ({ name, degree: longitude, speed })),
                    ascendant: apiDataTransit.ascendant,
                    midheaven: apiDataTransit.midheaven,
                    points: apiDataTransit.points || [],
                    houseCusps: apiDataTransit.houseCusps,
                    location: transitLocation,
                    timestamp: transitTimestamp,
                    chartType: 'transit'
                };
            }
            
            // Utility functions
            async function geocodeLocation(locationString, errorElement) {
                errorElement.textContent = '';
                try {
                    const params = `q=${encodeURIComponent(locationString)}&limit=1`;
                    const response = await fetch(`https://photon.komoot.io/api/?${params}`);
                    const data = await response.json();

                    if (data?.features?.length > 0) {
                        const feature = data.features[0];
                        const coordinates = feature.geometry.coordinates;
                        return {
                            latitude: coordinates[1],
                            longitude: coordinates[0]
                        };
                    }
                    errorElement.textContent = 'Location not found. Please enter a valid city and country.';
                    return null;
                } catch (error) {
                    console.error('Geocoding error:', error);
                    errorElement.textContent = 'Failed to geocode location.';
                    return null;
                }
            }
            
            async function getPlanetaryPositions(date, time, lat, lng, houseSystem, errorElement) {
                errorElement.textContent = '';
                try {
                    const url = `${ASTROLOGY_API_ENDPOINT}?date=${date}&time=${time}&lat=${lat}&lng=${lng}&house_system=${houseSystem}`;
                    const response = await fetch(url);
                    if (!response.ok) {
                        errorElement.textContent = `API error: ${response.statusText || response.status}`;
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return await response.json();
                } catch (error) {
                    console.error('API error:', error);
                    errorElement.textContent = 'Failed to get astrological data from API.';
                    throw new Error('Failed to get astrological data');
                }
            }

            // Initialize the application
            initializeCharts();

            // Restore saved mode preference
            const savedMode = localStorage.getItem('chartMode');
            if (savedMode === 'humandesign') {
                setMode('humandesign');
            }
        });
    </script>
</body>
</html>
